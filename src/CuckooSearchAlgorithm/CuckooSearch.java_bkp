package CuckooSearchAlgorithm;

import java.io.BufferedReader;
import java.io.BufferedWriter;
//import java.io.BufferedReader;
import java.io.File;
//import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
//import java.io.FileOutputStream;
//import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
//import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
//import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

//import org.jfree.data.xy.XYSeries;

/**
 *
 * @author Nicolás Caselli Benavente Phd Informática PUCV
 */
public class CuckooSearch extends Thread{

	private static int num_nidos; //número de población de nidos(soluciones)
	private static float probDescubrimiento;  //Probabilidad de descubrir el nido(solución) por la especie dueña de este.
//	private static int num_dimensiones; //Número de dimensiones o variables del problema SCP en este caso.
	private static int numIteraciones; //Número de iteraciones del ciclo de búsqueda.
	private static String tipoBinarizacion;
	private static String tipoDiscretizacion;
	private static int nidos[][];
	private static int costos[];
	private static int restricciones[][];
	private static int numeroFilas, numeroColumnas;
	private static float bestFit;
	private static long tiempoInicioEjecucion, tiempoInicioGlobal, tiempoTermino;
	private static long semilla;
	private static boolean fs, ss;
	private static Map<Integer, String> mNombresInstancias = new HashMap<Integer, String>(); 
	private static Map<Integer, Integer> mBestFistInstancias = new HashMap<Integer, Integer>();
//	private Random rnd;
    /**
     * {@code logger} = Log de errores
     */
    private static final Logger logger = Logger.getLogger(CuckooSearch.class.getName());
	 /**
     * {@code rows} = Filas de M {@code cols} = Columnas de M
     */
    private static int rows, cols;
    /**
     * {@code rs} = Restricciones {@code rc} = Restricciones cubiertas
     * {@code cc} = Contador de costos {@code cr} = Contador de restricciones
     * {@code fc} = Contador de fitness {@code tf} = Total fitness
     */
    private static int rs, rc, cc, cr;
	/**
	 * {@code input} = ubicacion del archivo SCP {@code output} = Nombre y
	 * ubicacion del archivo de resultados
	 */
	private String inPut;
	/**
	 * {@code outPut} = ubicacion del archivo SCP {@code output} = Nombre y
	 * ubicacion del archivo de resultados
	 */
	private String outPut;

	public long getSemilla() {
		return semilla;
	}

	public void setSemilla(long semilla) {
		this.semilla = semilla;
	}

	public String getInPut() {
		return inPut;
	}

	public void setInPut(String inPut) {
		this.inPut = inPut;
	}

	public String getOutPut() {
		return outPut;
	}

	public void setOutPut(String outPut) {
		this.outPut = outPut;
	}

	public long getTiempoInicioEjecucion() {
		return tiempoInicioEjecucion;
	}

	public void setTiempoInicioEjecucion(long tiempoInicioEjecucion) {
		this.tiempoInicioEjecucion = tiempoInicioEjecucion;
	}

	public long getTiempoInicioGlobal() {
		return tiempoInicioGlobal;
	}

	public void setTiempoInicioGlobal(long tiempoInicioGlobal) {
		this.tiempoInicioGlobal = tiempoInicioGlobal;
	}

	public long getTiempoTermino() {
		return tiempoTermino;
	}

	public void setTiempoTermino(long tiempoTermino) {
		this.tiempoTermino = tiempoTermino;
	}

	public String getTipoBinarizacion() {
		return tipoBinarizacion;
	}

	CuckooSearch(int cantNidos, float probabilidad,  int numeroiteraciones,
						Map<Integer, String> mInstanciasAprocesar, 
						Map<Integer, Integer> mMejoresFitsInstancias,
						String discretizacion,
						String binarizacion,
						int [] vectorCostos,
						int [] matrizRestricciones[],
						int numFilas,
						int numColumnas) { //Constructor
		num_nidos = cantNidos;
		probDescubrimiento = probabilidad;
//		num_dimensiones = 0;
		numIteraciones = numeroiteraciones;
		tipoDiscretizacion = discretizacion;
		tipoBinarizacion = binarizacion;
		mNombresInstancias = mInstanciasAprocesar;
		mBestFistInstancias = mMejoresFitsInstancias;
		nidos = null;
		costos = vectorCostos;
		restricciones = matrizRestricciones;
		bestFit = 0;
		tiempoInicioEjecucion = 0;
		tiempoInicioGlobal = System.currentTimeMillis();;
		tiempoTermino = 0;
		semilla = new Date().getTime();
		numeroColumnas = numColumnas;
		numeroFilas = numFilas;
//		rnd = new Random();
		

	}
	
	CuckooSearch(int cantNidos, float probabilidad,  int numeroiteraciones,Map<Integer, String> mInstanciasAprocesar, Map<Integer, Integer> mMejoresFitsInstancias, String discretizacion,  String binarizacion) { //Constructor
		num_nidos = cantNidos;
		probDescubrimiento = probabilidad;
//		num_dimensiones = 0;
		numIteraciones = numeroiteraciones;
		tipoDiscretizacion = discretizacion;
		tipoBinarizacion = binarizacion;
		mNombresInstancias = mInstanciasAprocesar;
		mBestFistInstancias = mMejoresFitsInstancias;
		nidos = null;
		costos = null;
		restricciones = null;
		bestFit = 0;
		tiempoInicioEjecucion = 0;
		tiempoInicioGlobal = System.currentTimeMillis();;
		tiempoTermino = 0;
		semilla = new Date().getTime();
//		rnd = new Random();
		

	}

	public void setBestFit (int bestFit)
	{
		this.bestFit = bestFit;
	}

	public float getBestFit() {
		return this.bestFit;
	}

	public void setInput(String input) {
		this.inPut = input;
	}

	public void setOutput(String output) {
		this.outPut = output;
	}

	public void setTipoBinarizacion(String tipoBinarizacion) {
		this.tipoBinarizacion = tipoBinarizacion;
	}

	public int getNum_nidos() {
		return num_nidos;
	}
	public void setNum_nidos(int num_nidos) {
		this.num_nidos = num_nidos;
	}
	public float getProbDescubrimiento() {
		return probDescubrimiento;
	}
	public void setProbDescubrimiento(float probDescubrimiento) {
		this.probDescubrimiento = probDescubrimiento;
	}
//	public int getNum_dimensiones() {
//		return num_dimensiones;
//	}
//	public void setNum_dimensiones(int num_dimensiones) {
//		this.num_dimensiones = num_dimensiones;
//	}
	public int getNumIteraciones() {
		return numIteraciones;
	}
	public void setNumIteraciones(int n_iter_total) {
		this.numIteraciones = n_iter_total;
	}
	public int[][] getNidos() {
		return nidos;
	}
	public void setNidos(int[][] nidos) {
		this.nidos = nidos;
	}
	public int[] getCostos() {
		return costos;
	}
	public void setCostos(int[] costos) {
		this.costos = costos;
	}
	public int[][] getRestricciones() {
		return restricciones;
	}
	public void setRestricciones(int[][] restricciones) {
		this.restricciones = restricciones;
	}
	/*Este método inicializa las soluciones de manera binaria y aleatoria*/
	private int[][] inicializacionSoluciones() throws FileNotFoundException, IOException {
		Random rnd = new Random(System.nanoTime());
		int nest[][] = new int[this.num_nidos][this.numeroColumnas];
		for (int i = 0; i < this.num_nidos; i++) {
			for (int j = 0; j < this.numeroColumnas; j++) {
				nest[i][j] = rnd.nextInt(2);
//				nest[i][j] = this.discretizacion(this.binarizacion(rnd.nextFloat(), tipoBinarizacion), tipoDiscretizacion);
			}
			nest[i] = this.evaluarRestriccionesYRepara(nest[i], restricciones, costos);
		}
		return nest;
	}
	
	/**
	 * Esta función recorre la lista de restricciones, y encuentra la columna que tenga el menos valor de ponderación (Costo columna / suma de 1's de dicha columna)
	 * @param arrayList arreglo con restricciones a evaluar
	 * @param restricciones
	 * @param costos
	 * @return
	 */
	private Integer ColumnaMenorCosto(ArrayList<Integer> arrayList, int restricciones[][], int costos[]) {
		double nValor = 0;
		double nValorTemp = 0;
		int nFila = 0;
		int cont = 0;

		for (Integer nColumna : arrayList) {
			double sum = 0;
			for (int i = 0; i < restricciones.length; i++) {
				if (restricciones[i][nColumna] == 1) {
					sum++;
				}
			}
			if (cont == 0) {
				nValor = costos[nColumna] / sum;
				nValorTemp = costos[nColumna] / sum;
				nFila = nColumna;
			} else {
				nValorTemp = costos[nColumna] / sum;
			}
			if (nValorTemp < nValor) {
				nValor = nValorTemp;
				nFila = nColumna;
			}
			cont++;
		}

		return nFila;
	}

	private int[] evaluarRestriccionesYRepara(int nest[], int restricciones[][], int costos[]) {
		
		//valida que cada columna sea cubierta por almenos un valor de alguna fila del nido
		boolean bComprobacion = false;
		for (int i = 0; i < restricciones.length; i++) {
			bComprobacion = false;
			for (int j = 0; j < restricciones[i].length; j++) {
				if (nest[j] * restricciones[i][j] == 1) {
					bComprobacion = true;
					break;
				}
			}
			if (bComprobacion == false) {
				break;
			}
		}


		if (bComprobacion == false) {		//Si existe alguna restricción qu eno se cumpla, caemos acá
			Map<Integer, ArrayList<Integer>> aListColRestr = new HashMap<Integer, ArrayList<Integer>>(); //lista de columnas restricciones, con su respectivo índice
			Map<Integer, ArrayList<Integer>> aListFilRestr = new HashMap<Integer, ArrayList<Integer>>();	//lista de filas restricciones, con su respectivo índice
			ArrayList<Integer> aListU = new ArrayList<Integer>(); //lista que contemdrá todas las filas que violan resticcion
			ArrayList<Integer> aListW = new ArrayList<Integer>();

			//Este for, es el simil al "find" de matlab, que devuelve los índices del vector cuyos valores no son ceros
			for (int i = 0; i < restricciones.length; i++) { //recorre, por cada fila, todas las columnas, y aquellas que son restrictivas las guarda
				aListU.add(i);
				ArrayList<Integer> aListTemp = new ArrayList<Integer>();
				for (int j = 0; j < restricciones[i].length; j++) {
					if (restricciones[i][j] == 1) {
						aListTemp.add(j);
					}
				}
				aListColRestr.put(i, aListTemp);//para la fila i, todas las columnas con 1--> asigna lista de índices de columnas con valor 1 en la restricción i
			}

			for (int j = 0; j < restricciones[0].length; j++) { //recorre, por cada columna, todas las filas, y aquellas que son restrictivas las guarda
				ArrayList<Integer> aListTemp = new ArrayList<Integer>();
				for (int i = 0; i < restricciones.length; i++) {
					if (restricciones[i][j] == 1) {
						aListTemp.add(i);
					}
				}
				aListFilRestr.put(j, aListTemp);//para la columna j, todas las filas con 1 --> asigna lista de índices de filas con valor 1 en la restricción i
			}

			for (int i = 0; i < restricciones.length; i++) {
				for (int j = 0; j < restricciones[i].length; j++) {
					if (nest[j] * restricciones[i][j] == 1) {	//si en el nido j no viola restricción, se elimina el id de la fila de la lista 
						if (aListU.contains((Object) i)) {
							aListU.remove((Object) i);
						}
						break;
					}
				}
			}
			HashSet<Integer> hashSet = new HashSet<Integer>(aListU);
			aListU.clear();
			aListU.addAll(hashSet);

			//ACÁ COMIENZA LA REPARACIÓN DEL NIDO

			while (!aListU.isEmpty()) { //MIENTRAS QUEDEN COLUMNAS POR CORREGIR
				int nFila = 0;
				for (Integer fila : aListU) {
					nFila = fila;
					break;
				}
				Integer nColumnSel = ColumnaMenorCosto(aListColRestr.get(nFila), restricciones, costos); //busca la columna de mayor ajuste (la que tenga mas opciones de ser reemplazada)
				nest[nColumnSel] = 1;

				for (Integer nFilaDel : aListFilRestr.get(nColumnSel)) {
					if (aListU.contains((Object) nFilaDel)) {
						aListU.remove((Object) nFilaDel);	//DADO QUE CORREGÍ ARRIBA, QUITO LA FILA DE LA LISTA --> borra la fila completa, pues tiene otra columna que la resuelve
					}
				}
			}
			//LUEGO DE CORREGIR, VALIDAMOS CUÁNTAS FILAS QUEDAN SIN RESTRICCION POR CADA COLUMNA
			int contFila = 0;
			for (int i = 0; i < restricciones.length; i++) {
				contFila = 0;
				for (int j = 0; j < restricciones[i].length; j++) {
					if (nest[j] * restricciones[i][j] == 1) {
						contFila++;
					}
				}
				aListW.add(contFila); //se agregan tantos elementos como filas con 1 existan en el nido
			}

			aListU = null;
			ArrayList<Integer> aNumRow = null;
			boolean bComp = false;
			for (int j = nest.length - 1; j >= 0; j--) {
				bComp = false;
				aNumRow = new ArrayList<Integer>();
				if (nest[j] == 1) {
					for (int i = 0; i < restricciones.length; i++) {
						if (restricciones[i][j] == 1) {
							if (aListW.get(i) >= 2) { //si la fila tiene más de dos alternativas, se guarda su índice
								aNumRow.add(i);			//agrega el número de la fila al arreglo
								bComp = true;
							} else {
								bComp = false;
								break;
							}
						}
					}

					if (bComp) {
						for (Integer i : aNumRow) {//para todas aquellas filas que tenían más de una solución, se les resta una solución
							aListW.set(i, aListW.get(i) - 1);
						}
						nest[j] = 0;//y el valor del nido se deja en cero (chanchamente a cero)
						//System.out.print("cambiando el valor del nido en la posicion:" +j+" \n");

					}
				}
			}
		}
		return nest;
	}
	/**
	 * Funcion que deja el valor del fitnes en 10^10
	 * @param fitness
	 */
	private void inicializacionFitness(float fitness[]) {
		for (int i = 0; i < this.num_nidos; i++) {
			fitness[i] = (float) Math.pow((double) 10, (double) 10);
		}
	}

	private static double erf(double z) {

		double q = 1.0 / (1.0 + 0.5 * Math.abs(z));

		double ans = 1 - q * Math.exp(-z * z - 1.26551223
				+ q * (1.00002368
						+ q * (0.37409196
								+ q * (0.09678418
										+ q * (-0.18628806
												+ q * (0.27886807
														+ q * (-1.13520398
																+ q * (1.48851587
																		+ q * (-0.82215223
																				+ q * (0.17087277))))))))));

		return z >= 0 ? ans : -ans;
	}

	private int binarizacion(float f, Random rnd, String tipoBinarizacion) throws FileNotFoundException, IOException {
		
		switch (tipoBinarizacion){
			case "sshape1":
//				return (1/(1+Math.pow(Math.E,-2*f)));
//				
//			case "sshape2":
//				return (1 / (1 + Math.pow(Math.E, -f)));
//				
//			case "sshape3":
//				return (1/(1+Math.pow(Math.E,-1*f/2)));
//				
//			case "sshape4":
//				return (1/(1+Math.pow(Math.E,-1*f/3)));
//	
//			case "vshape1":
//				return Math.abs(erf((Math.sqrt(Math.PI) / 2) * f));
	
			case "vshape2":
//				return Math.abs((float)Math.tan(f));
				return rnd.nextFloat() <= Math.abs((float)Math.tan(f)) ? 1:0;
	
			case "vshape3":
//				return Math.abs(f/Math.sqrt(1+Math.pow(f, 2)));
//	
//			case "vshape4":
//				return Math.abs(f/Math.sqrt(1+Math.pow(f, 2)));
//	
//			case "vshape5":
//				return Math.abs(2/Math.PI*Math.atan(Math.PI/2*f));        	
			case "basic":
				return 0.5 <= f ? 1 : 0;
			default:
				return 0;

		}

	}

	private int discretizacion(double x, Random rnd, String tipoDiscretizacion) throws FileNotFoundException, IOException {
		double alpha = 0.4;
		switch (tipoDiscretizacion){
			case "standard":
				return rnd.nextFloat() <= x ? 1 : 0;
			case "complement":
				return rnd.nextFloat() <= x ? discretizacion(1-x, rnd,  "standard" ) : 0;
			case "staticProbability":
				return alpha >= x ? 0 : (alpha < x && x <= ((1 + alpha) / 2)) ? discretizacion(x, rnd, "standard" ) : 1;
			case "elitist":
				return rnd.nextFloat() < x ? discretizacion(x, rnd, "standard" ) : 0;
			default:
				return 0;

		}

	}
	/**
	 * Evalua la F.O. en todos los nidos, y devuelve el índice del nido con mejor fitnes entre todos
	 * @param nidos
	 * @param nuevosnidos
	 * @param fitness
	 * @param costos
	 * @param asd jamaz se usa...
	 * @return
	 */
	private int obtenerMejorNido(int nidos[][], int nuevosnidos[][], float fitness[], int costos[], String asd) {
		int mejorposicion = -1;
		float costo = 0;
		float aux = 1000000000;
		for (int i = 0; i < this.num_nidos; i++) { //evaluando todos los "nuevos nidos" en la f.o y comparandolos con el anterior!
			for (int j = 0; j < this.numeroColumnas; j++) {
				costo = costo + this.funcionObjetivo(nuevosnidos[i][j], j, costos);
			}

			if (costo < fitness[i]) {
				for (int k = 0; k < this.numeroColumnas; k++) {
					nidos[i][k] = nuevosnidos[i][k];
				}
				fitness[i] = costo;
			}
			costo = 0;
		}
		for (int i = 0; i < fitness.length; i++) { //obteniendo el mejor nido
			if (aux > fitness[i]) {
				aux = fitness[i];
				mejorposicion = i;
			}
		}
		return mejorposicion;
	}
	/**
	 * Genera de manera aleatorea los  valores para los nidos, para cada valor los binariza, luego repara los valores que violan restricciones.    
	 * @param nidos
	 * @param posicionmejor
	 * @param restricciones
	 * @param costos
	 * @param fitness
	 * @param rnd
	 * @param alfa
	 * @param tipoBinarizacion
	 * @return
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	private int[][] generarNuevasSoluciones(int nidos[][], int posicionmejor, int restricciones[][], int costos[], Random rnd, float fitness[],  float alfa, String tipoBinarizacion, String tipoDiscretizacion) throws FileNotFoundException, IOException {
		int solucionCorrecta = 0;
		int nuevosnidos[][] = new int[this.num_nidos][this.numeroColumnas];
		float beta = (float) 3 / 2;
		float sigma;
		float[] paso = new float[this.numeroColumnas];
		float[] tamanoPaso = new float[this.numeroColumnas];
		float[] u = new float[this.numeroColumnas];
		float[] v = new float[this.numeroColumnas];
		//sigma = (float) Math.pow(((Gamma.gamma((float)1+beta)*Math.sin(Math.PI*beta/2)))/(Gamma.gamma(((float)1+beta)/2)*beta*Math.pow(2,(float)(beta-1)/2)),(float)(1/beta));//(1/beta));               
		sigma = (float) 0.69657;
		for (int i = 0; i < this.numeroColumnas; i++) {
			u[i] = (float) (rnd.nextGaussian() * sigma);
			v[i] = (float) rnd.nextGaussian();
			paso[i] = (float) (float) u[i] / (float) Math.abs(v[i]);
			paso[i] = (float) Math.pow(paso[i], 2);
			paso[i] = (float) Math.cbrt(paso[i]);
		}
		for (int i = 0; i < this.num_nidos; i++) {
			for (int j = 0; j < this.numeroColumnas; j++) {
				//if(i != posicionmejor){
				float valor = (float) (nidos[i][j] + ((float) ((float) alfa * (float) paso[j]) * (nidos[posicionmejor][j] - nidos[i][j]) * rnd.nextGaussian()));
				//this.test(valor,0);
				if (valor < 0) { //LOWER BOUNDS
					nuevosnidos[i][j] = 0;
				} else if (valor > 1) {//UPPER BOUNDS
					nuevosnidos[i][j] = 1;
				} else {
					nuevosnidos[i][j] = this.binarizacion(valor, rnd, tipoBinarizacion);
//					nuevosnidos[i][j] = this.discretizacion(this.binarizacion(valor, tipoBinarizacion), rnd, tipoDiscretizacion);
				}
				//}else{
				//    nuevosnidos[i][j] = nidos[i][j];
				//}
			}
			this.evaluarRestriccionesYRepara(nuevosnidos[i], restricciones, costos);
		}
		return nuevosnidos;
	}
	/**
	 * similar a generarNuevasSoluciones, crea nidos nuevos de maner aleatorea, binariza luego repara.
	 * @param nidos
	 * @param posicionmejor
	 * @param restricciones
	 * @param rnd
	 * @param alfa
	 * @param costos
	 * @param tipoBinarizacion
	 * @return
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	private int[][] nidosVacios(int nidos[][], int posicionmejor, int restricciones[][], Random rnd, float alfa, int costos[], String tipoBinarizacion, String tipoDiscretizacion) throws FileNotFoundException, IOException {
		int nuevosnidos[][] = new int[this.num_nidos][this.numeroColumnas];
		for (int i = 0; i < this.num_nidos; i++) {
			int filaRandom1 = rnd.nextInt(this.num_nidos);
			int filaRandom2 = rnd.nextInt(this.num_nidos);


			if (rnd.nextFloat() > this.probDescubrimiento) { //si la especie dueña del nido descubre el huevo ajeno, se va a otro nido.
				for (int j = 0; j < this.numeroColumnas; j++) {
					float valor = (float) (nidos[i][j] + ((float) rnd.nextFloat() * (nidos[filaRandom1][j] - nidos[filaRandom2][j])));
					if (valor < 0) { //LOWER BOUNDS
						nuevosnidos[i][j] = 0;
					} else if (valor > 1) {//UPPER BOUNDS
						nuevosnidos[i][j] = 1;
					} else {
						nuevosnidos[i][j] = this.binarizacion(valor, rnd,  tipoBinarizacion);
					}
				}
				this.evaluarRestriccionesYRepara(nuevosnidos[i], restricciones, costos);
			} else {
				for (int j = 0; j < this.numeroColumnas; j++) {
					nuevosnidos[i][j] = nidos[i][j];
				}
			}
		}
		return nuevosnidos;
	}

	private float funcionObjetivo(int b, int dimension, int costos[]) {
		return b * costos[dimension];
	}

	private float funcionObjetivo(int nido[], int costos[]) {
		int costo = 0;
		for (int i=0; i< costos.length; i++)
			costo += nido[i]*costos[i];
		return costo;
	}
	/* funciones relacionadas al manejo de instancias y escritura de resultados
	 * en archivos planos, para utilizarlos posteriormente
	 * */
	
	/**
	 * Función que procesa línea de archivo unicos de librería OR
	 * Cada línea que lee la convierte según el formato de dicha instancia, logrando 
	 * asignar los valores a las variables de restricciones, filas, columnas y costos.
	 * @param line línea de archivo unicost a procesar
	 */
	public static void ProcesarLinea(String line) {
        String[] values = line.trim().split(" ");
        if (fs) {
            numeroFilas = Integer.parseInt(values[0]);
            numeroColumnas = Integer.parseInt(values[1]);
            restricciones = new int[numeroFilas][numeroColumnas];
            costos = new int[numeroColumnas];
//System.out.print("numeroColumnas:" +numeroColumnas);
            fs = false;
        } else {
            if (ss) {
                for (int i = 0; i < values.length; i++) {
                    costos[cc++] = Integer.parseInt(values[i]);
                }
                ss = cc < numeroColumnas;
            } else {
                if (rc == 0) {
                    rc = Integer.parseInt(values[0]);
                } else {
                    for (int i = 0; i < values.length; i++) {
                        restricciones[rs][Integer.parseInt(values[i]) - 1] = 1;
                        cr++;
                    }
                    if (rc <= cr) {
                        rs++;
                        rc = 0;
                        cr = 0;
                    }
                }
            }
        }
    }
	
	/**
	 * Función que inicia la lectura de archivo unicos, resive la ruta y el nombre de la instancia.
	 * @param rutaYnombreInstancia
	 */
	public static void LeeArchivoInstancia(String rutaYnombreInstancia) {
	    	fs = true;
	        ss = true;

	        rs = 0;
	        rc = 0;
	        cc = 0;
	        cr = 0;
	        BufferedReader br = null;
	        String line;

	        try {
	            br = new BufferedReader(new FileReader(rutaYnombreInstancia));
	            while ((line = br.readLine()) != null) {
	                ProcesarLinea(line);
	            }
	        } catch (IOException ex) {
	            logger.log(Level.SEVERE, null, ex);
	        } finally {
	            try {
	                if (br != null) {
	                    br.close();
	                }
	            } catch (IOException ex) {
	                logger.log(Level.SEVERE, null, ex);
	            }
	        }
	    }
	  
	public static int cargaInstancias(int cantidadInstancias)
		{
			Map<Integer, String> mInstanciasNombres = new HashMap<Integer, String>(); //lista de columnas restricciones, con su respectivo índice
			Map<Integer, Integer> mInstanciasBestFit = new HashMap<Integer, Integer>(); //lista de columnas restricciones, con su respectivo índice
	        
//			mInstanciasNombres.put(1,"mscp46.txt"); mInstanciasBestFit.put( 1,560);
//			mInstanciasNombres.put(1,"mscpc5.txt"); mInstanciasBestFit.put( 1,215);
			
			mInstanciasNombres.put(1,"mscp41.txt"); mInstanciasBestFit.put( 1,429);
			mInstanciasNombres.put(2,"mscp42.txt"); mInstanciasBestFit.put( 2,512);
			mInstanciasNombres.put(3,"mscp43.txt"); mInstanciasBestFit.put( 3,516);
			mInstanciasNombres.put(4,"mscp44.txt"); mInstanciasBestFit.put( 4,494);
			mInstanciasNombres.put(5,"mscp45.txt"); mInstanciasBestFit.put( 5,512);
			mInstanciasNombres.put(6,"mscp46.txt"); mInstanciasBestFit.put( 6,560);
			mInstanciasNombres.put(7,"mscp47.txt"); mInstanciasBestFit.put( 7,430);
			mInstanciasNombres.put(8,"mscp48.txt"); mInstanciasBestFit.put( 8,492);
			mInstanciasNombres.put(9,"mscp49.txt"); mInstanciasBestFit.put( 9,641);
			mInstanciasNombres.put(10,"mscp410.txt"); mInstanciasBestFit.put( 10,514);
			mInstanciasNombres.put(11,"mscp51.txt"); mInstanciasBestFit.put( 11,253);
			mInstanciasNombres.put(12,"mscp52.txt"); mInstanciasBestFit.put( 12,302);
			mInstanciasNombres.put(13,"mscp53.txt"); mInstanciasBestFit.put( 13,226);
			mInstanciasNombres.put(14,"mscp54.txt"); mInstanciasBestFit.put( 14,242);
			mInstanciasNombres.put(15,"mscp55.txt"); mInstanciasBestFit.put( 15,211);
			mInstanciasNombres.put(16,"mscp56.txt"); mInstanciasBestFit.put( 16,213);
			mInstanciasNombres.put(17,"mscp57.txt"); mInstanciasBestFit.put( 17,293);
			mInstanciasNombres.put(18,"mscp58.txt"); mInstanciasBestFit.put( 18,288);
			mInstanciasNombres.put(19,"mscp59.txt"); mInstanciasBestFit.put( 19,279);
			mInstanciasNombres.put(20,"mscp51.txt"); mInstanciasBestFit.put( 20,265);
			mInstanciasNombres.put(21,"mscp61.txt"); mInstanciasBestFit.put( 21,138);
			mInstanciasNombres.put(22,"mscp62.txt"); mInstanciasBestFit.put( 22,146);
			mInstanciasNombres.put(23,"mscp63.txt"); mInstanciasBestFit.put( 23,145);
			mInstanciasNombres.put(24,"mscp64.txt"); mInstanciasBestFit.put( 24,131);
			mInstanciasNombres.put(25,"mscp65.txt"); mInstanciasBestFit.put( 25,161);
			mInstanciasNombres.put(26,"mscpa1.txt"); mInstanciasBestFit.put( 26,253);
			mInstanciasNombres.put(27,"mscpa2.txt"); mInstanciasBestFit.put( 27,252);
			mInstanciasNombres.put(28,"mscpa3.txt"); mInstanciasBestFit.put( 28,232);
			mInstanciasNombres.put(29,"mscpa4.txt"); mInstanciasBestFit.put( 29,234);
			mInstanciasNombres.put(30,"mscpa5.txt"); mInstanciasBestFit.put( 30,236);
			mInstanciasNombres.put(31,"mscpb1.txt"); mInstanciasBestFit.put( 31,69);
			mInstanciasNombres.put(32,"mscpb2.txt"); mInstanciasBestFit.put( 32,76);
			mInstanciasNombres.put(33,"mscpb3.txt"); mInstanciasBestFit.put( 33,80);
			mInstanciasNombres.put(34,"mscpb4.txt"); mInstanciasBestFit.put( 34,79);
			mInstanciasNombres.put(35,"mscpb5.txt"); mInstanciasBestFit.put( 35,72);
			mInstanciasNombres.put(36,"mscpc1.txt"); mInstanciasBestFit.put( 36,227);
			mInstanciasNombres.put(37,"mscpc2.txt"); mInstanciasBestFit.put( 37,219);
			mInstanciasNombres.put(38,"mscpc3.txt"); mInstanciasBestFit.put( 38,243);
			mInstanciasNombres.put(39,"mscpc4.txt"); mInstanciasBestFit.put( 39,219);
			mInstanciasNombres.put(40,"mscpc5.txt"); mInstanciasBestFit.put( 40,215);
			mInstanciasNombres.put(41,"mscpd1.txt"); mInstanciasBestFit.put( 41,60);
			mInstanciasNombres.put(42,"mscpd2.txt"); mInstanciasBestFit.put( 42,66);
			mInstanciasNombres.put(43,"mscpd3.txt"); mInstanciasBestFit.put( 43,72);
			mInstanciasNombres.put(44,"mscpd4.txt"); mInstanciasBestFit.put( 44,62);
			mInstanciasNombres.put(45,"mscpd5.txt"); mInstanciasBestFit.put( 45,61);
			mInstanciasNombres.put(46,"mscpnre1.txt"); mInstanciasBestFit.put( 46,29);
			mInstanciasNombres.put(47,"mscpnre2.txt"); mInstanciasBestFit.put( 47,30);
			mInstanciasNombres.put(48,"mscpnre3.txt"); mInstanciasBestFit.put( 48,27);
			mInstanciasNombres.put(49,"mscpnre4.txt"); mInstanciasBestFit.put( 49,28);
			mInstanciasNombres.put(50,"mscpnre5.txt"); mInstanciasBestFit.put( 50,28);
			mInstanciasNombres.put(51,"mscpnrf1.txt"); mInstanciasBestFit.put( 51,14);
			mInstanciasNombres.put(52,"mscpnrf2.txt"); mInstanciasBestFit.put( 52,15);
			mInstanciasNombres.put(53,"mscpnrf3.txt"); mInstanciasBestFit.put( 53,14);
			mInstanciasNombres.put(54,"mscpnrf4.txt"); mInstanciasBestFit.put( 54,14);
			mInstanciasNombres.put(55,"mscpnrf5.txt"); mInstanciasBestFit.put( 55,13);
			mInstanciasNombres.put(56,"mscpnrg1.txt"); mInstanciasBestFit.put( 56,176);
			mInstanciasNombres.put(57,"mscpnrg2.txt"); mInstanciasBestFit.put( 57,154);
			mInstanciasNombres.put(58,"mscpnrg3.txt"); mInstanciasBestFit.put( 58,166);
			mInstanciasNombres.put(59,"mscpnrg4.txt"); mInstanciasBestFit.put( 59,168);
			mInstanciasNombres.put(60,"mscpnrg5.txt"); mInstanciasBestFit.put( 60,168);
			mInstanciasNombres.put(61,"mscpnrh1.txt"); mInstanciasBestFit.put( 61,63);
			mInstanciasNombres.put(62,"mscpnrh2.txt"); mInstanciasBestFit.put( 62,63);
			mInstanciasNombres.put(63,"mscpnrh3.txt"); mInstanciasBestFit.put( 63,59);
			mInstanciasNombres.put(64,"mscpnrh4.txt"); mInstanciasBestFit.put( 64,58);
			mInstanciasNombres.put(65,"mscpnrh5.txt"); mInstanciasBestFit.put( 65,55);
	        
	        for (int i=1;i<=cantidadInstancias;i++) {
	        	mBestFistInstancias.put(i, mInstanciasBestFit.get(i));
	        	mNombresInstancias.put(i,  mInstanciasNombres.get(i));
	        }
	        	
			return 0;
		}

	 private static String Write(int b, Object o) {
	        String line = "";
	        for (int i = 0; i < b - String.valueOf(o).length(); i++) {
	            line += " ";
	        }
	        return (line + o + " |");
	    }
	/**
	 * escribe los resultados de cada ejecución en @filename	
	 * @param ejecucion es el número de la ejecucion
	 * @param fileName es el archivo dónde se escriben los resultados
	 * @param knowFitInstancia es el mejor resultado conocido de dicha instancia
	 * @param nombreInstancia es el nombre del archivo OR utilizado
	 */
	private static void Save(int ejecucion, String fileName, int knowFitInstancia, String nombreInstancia) {
//			|Nº EJECUCION | NIDOS | discretizacion  | BINARIZACION  |ITERACIONES|  SEMILLA     | MEJOR FITNESS |    FITNESS FOUND| TIME |\n");
	        BufferedWriter bufferedWriter = null;
	        File file;
	        String line = "|";

	        try {
	            file = new File(fileName);
	            boolean exists = file.exists();

	            if (!exists) {
	                (new File(file.getParent())).mkdirs();
	            }

	            bufferedWriter = new BufferedWriter(new FileWriter(file, true));

	            try (PrintWriter pw = new PrintWriter(bufferedWriter)) {
	                if (!exists) {
	                    line += Write(2, "#") + 
	                    		Write(5, "Nest") +
	                    		Write(13, "Discretizacion") +
	                    		Write(13, "Binarizacion") + 
	                    		Write(6, "%Desc") + 
	                    		Write(5, "#Iter") + 
	                    		Write(13, "semilla") + 
	                    		Write(8, "BestFit");
	                    
	                    line += Write(8, "GottedFit") + 
	                    		Write(11, "instancia") + 
	                    		Write(5, "time");
	                    pw.println(line);
	                    line = "";
	                    for (int i = 0; i < 97; i++) {
	                        line += "-";
	                    }
	                    pw.println(line);
	                    line = "|";
	                }

	                line += Write(2, ejecucion) + 
	                		Write(5, num_nidos) +
	                		Write(13, tipoDiscretizacion) +
	                		Write(13, tipoBinarizacion) + 
	                		Write(6, probDescubrimiento) + 
	                		Write(5, numIteraciones) + 
	                		Write(13, semilla) + 
	                		Write(8, knowFitInstancia) +
	                		Write(8, bestFit);
	                line += Write(11, nombreInstancia) +  
	                		Write(5, (String.format("%.2g%n", (tiempoTermino-tiempoInicioEjecucion) / (1000f))).trim());
	                pw.println(line);
	            }
	        } catch (IOException ex) {
	            logger.log(Level.SEVERE, null, ex);
	        } finally {
	            try {
	                if (bufferedWriter != null) {
	                    bufferedWriter.close();
	                }
	            } catch (IOException ex) {
	                logger.log(Level.SEVERE, null, ex);
	            }
	        }
	    }
	@Override
	public String toString() {
		return ("Numero de nidos:" + this.num_nidos + "\n" + "Numero de dimensiones:" + this.numeroColumnas + "\n" + "Operador probabilidad:" + this.probDescubrimiento + "\n" + "Numero de Iteraciones:" + this.numIteraciones + "\n");
	}

	@Override
	public  void run() {
		int repActual = 1;//Integer.parseInt(args[0]);
		int posicionmejor,aux = 0, i=0;
		int nuevosnidos[][] = null;

		float alfa = (float) 0.01;
		try {
//			 System.out.print("en Clase Cuckoo:\n NumeroFilas:"+ numeroFilas +"numeroCol"+ numeroColumnas + "costos:"+costos.length);
			int inst;
			for (inst =1; inst <= mNombresInstancias.size(); inst++) 
			{
//				esperarXsegundos(new Random().nextInt(5));
	            LeeArchivoInstancia("resources/input/" + mNombresInstancias.get(inst));
			 	System.out.print("Archivo: "+mNombresInstancias.get(inst)+"\nFilas: "+numeroFilas+"\nColumnas:"+numeroColumnas+"\n\n");
			 	System.out.print("|Nº EJECUCION | NIDOS | DISCRETIZACION  | BINARIZACION  |ITERACIONES|  SEMILLA     | MEJOR FITNESS |    FITNESS FOUND| TIME |\n");
	            System.out.print("|___________________________________________________________________________________________\n");
	            
			
				for (int numEjecucion = 1; numEjecucion <= 31; numEjecucion++)
				{
		
					int mejorIteracion = 0;
					Random rnd;
					rnd = new Random();
					
					tiempoInicioEjecucion = System.currentTimeMillis();
					//	        System.out.print("EXPERIMENTO ID:" + id + "\n\n\n");
					semilla = new Date().getTime();
					rnd.setSeed(semilla);
					float fitness[] = new float[num_nidos];
		
		
					nidos = this.inicializacionSoluciones(); //Inicializar nidos o soluciones || con valores aleatoreos               
					inicializacionFitness(fitness); //Inicializar el vector con las mejores soluciones para los nidos i-ésimos || laprimera vez todos los fitness en 10^10
					posicionmejor = this.obtenerMejorNido(nidos, nidos, fitness, costos, null);
					//hasta aquí solo inicializó la primera vez de evaluaciones, con valores aleatorios y fitness altísimos para poder dejar los valores iniciales.
		
		
					int auxPosicion = posicionmejor;
					bestFit = fitness[posicionmejor];
					i = 1;
		
					
					while (i <= numIteraciones) { //Aqui comienza a iterar el algoritmo CS.
						nuevosnidos = generarNuevasSoluciones(nidos, posicionmejor, restricciones, costos, rnd, fitness, alfa,tipoDiscretizacion, tipoBinarizacion); //Aqui se generarán nuevas soluciones aplicando LF                                                          
						posicionmejor = obtenerMejorNido(nidos, nuevosnidos, fitness, costos, "levy");
		
						if (posicionmejor != auxPosicion && fitness[posicionmejor] != bestFit) {
							auxPosicion = posicionmejor;
							bestFit = fitness[posicionmejor];
							mejorIteracion = i;
						}
						i++;
						nuevosnidos = nidosVacios(nidos, posicionmejor, restricciones, rnd, alfa, costos, tipoDiscretizacion, tipoBinarizacion);
						posicionmejor = obtenerMejorNido(nidos, nuevosnidos, fitness, costos, "p(a)");
						if (posicionmejor != auxPosicion && fitness[posicionmejor] != bestFit) {
							auxPosicion = posicionmejor;
							bestFit = fitness[posicionmejor];
							mejorIteracion = i;
						}
					}
					float fit = 0;
					for (i = 0; i < numeroColumnas; i++) {
						fit = fit + funcionObjetivo(nidos[posicionmejor][i], i, costos);
					}
					//	        System.out.print("\n\nMEJOR FITNESS:" + fit + " EN LA POSICION:" + posicionmejor + "\n");
					//	        for (i = 0; i < CS.num_dimensiones; i++) {
					//	            System.out.print(nidos[posicionmejor][i] + "\t");
					//	        }
					aux = 0;
					int sumatoria = 0;
					//	        System.out.print("\n\nCOMPROBANDO RESTRICCIONES...\n");
					for (i = 0; i < restricciones.length; i++) {
						for (int j = 0; j < numeroColumnas; j++) {
							if (restricciones[i][j] == 1 && nidos[posicionmejor][j] == 1) {
								sumatoria++;
								break;
							}
						}
					}
					if (sumatoria == restricciones.length) {
						//	            System.out.print("\n\nTODAS LAS RESTRICCIONES HAN SIDO CUBIERTAS, TOTAL:" + restricciones.length + "\n");
					} else {
						System.out.print("\n\nERROR EN PASO DE UNA O MAS RESTRICCION\n");
					}
					tiempoTermino = System.currentTimeMillis();
					System.out.print("|      " +numEjecucion+"     |     " + num_nidos + "    | " + tipoDiscretizacion +"    | " + tipoBinarizacion + "   |"+"     " + numIteraciones + "   |"+ semilla + "|    "+     mBestFistInstancias.get(inst)     +"      |      "+ bestFit+ "     |   " + (float)(tiempoTermino-tiempoInicioEjecucion)/1000+"|\n");
					
					/* guardamos resultados en archivo plano*/
	                Save(numEjecucion, 
	                		"resources/output/Salida_"+num_nidos+tipoDiscretizacion+tipoBinarizacion + numIteraciones +mNombresInstancias.get(inst),
	                		mBestFistInstancias.get(inst), 
	                		mNombresInstancias.get(inst) );
	                
				}
				System.out.println("Ejecuciones terminadas en: "+ (float)(tiempoTermino-tiempoInicioGlobal)/1000 );
			}

			//CS.generarExcel(numerofilas,numerocolumnas,numeroIteraciones,fitness[posicionmejor],fitness[posicionPeor],fBinarizacion,id,archivo.getName().replace(".txt", ""),repActual,tiempoInicio,mejorIteracion);
		} catch (Exception e) {
			e.printStackTrace();
			Thread.currentThread().interrupt();
		}

	}

	private void esperarXsegundos(int segundos) {
		try {
			System.out.println("Esperando por"+(segundos*1000)+"\n");
			Thread.sleep(segundos * 1000);
		} catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
}
