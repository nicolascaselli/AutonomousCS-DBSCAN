package CuckooSearchAlgorithm;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;



public class Main {
	public static List<String> instancias;
	public static int costos[];
	public static int restricciones[][];
	public static int numeroFilas, numeroColumnas;
	public static Map<Integer, String> mNombresInstancias = new HashMap<Integer, String>(); 
	public static Map<Integer, Integer> mBestFistInstancias = new HashMap<Integer, Integer>();
	public static Map<Integer, String> mTiposDeBinarizacion  = new HashMap<Integer, String>(); 
	public static int cantNidos = 25;
	public static float probDescub = (float)0.25;
	public static int numeroIteraciones = 2500; 
	public static int cantInstancias = 2;
	public static String binarizacion = "standard";
	public static boolean fs, ss;
	 /**
     * {@code rows} = Filas de M {@code cols} = Columnas de M
     */
    public static int rows, cols;
    /**
     * {@code rs} = Restricciones {@code rc} = Restricciones cubiertas
     * {@code cc} = Contador de costos {@code cr} = Contador de restricciones
     * {@code fc} = Contador de fitness {@code tf} = Total fitness
     */
    public static int rs, rc, cc, cr;
    /**
	
    /**
     * {@code logger} = Log de errores
     */
    private static final Logger logger = Logger.getLogger(CuckooSearch.class.getName());
	
	public static int cargaInstancias(int cantidadInstancias)
	{
		Map<Integer, String> mInstanciasNombres = new HashMap<Integer, String>(); //lista de columnas restricciones, con su respectivo índice
		Map<Integer, Integer> mInstanciasBestFit = new HashMap<Integer, Integer>(); //lista de columnas restricciones, con su respectivo índice
        
//		mInstanciasNombres.put(1,"mscp46.txt"); mInstanciasBestFit.put( 1,560);
//		mInstanciasNombres.put(1,"mscpc5.txt"); mInstanciasBestFit.put( 1,215);
		
		mInstanciasNombres.put(1,"mscp41.txt"); mInstanciasBestFit.put( 1,429);
		mInstanciasNombres.put(2,"mscp42.txt"); mInstanciasBestFit.put( 2,512);
		mInstanciasNombres.put(3,"mscp43.txt"); mInstanciasBestFit.put( 3,516);
		mInstanciasNombres.put(4,"mscp44.txt"); mInstanciasBestFit.put( 4,494);
		mInstanciasNombres.put(5,"mscp45.txt"); mInstanciasBestFit.put( 5,512);
		mInstanciasNombres.put(6,"mscp46.txt"); mInstanciasBestFit.put( 6,560);
		mInstanciasNombres.put(7,"mscp47.txt"); mInstanciasBestFit.put( 7,430);
		mInstanciasNombres.put(8,"mscp48.txt"); mInstanciasBestFit.put( 8,492);
		mInstanciasNombres.put(9,"mscp49.txt"); mInstanciasBestFit.put( 9,641);
		mInstanciasNombres.put(10,"mscp410.txt"); mInstanciasBestFit.put( 10,514);
		mInstanciasNombres.put(11,"mscp51.txt"); mInstanciasBestFit.put( 11,253);
		mInstanciasNombres.put(12,"mscp52.txt"); mInstanciasBestFit.put( 12,302);
		mInstanciasNombres.put(13,"mscp53.txt"); mInstanciasBestFit.put( 13,226);
		mInstanciasNombres.put(14,"mscp54.txt"); mInstanciasBestFit.put( 14,242);
		mInstanciasNombres.put(15,"mscp55.txt"); mInstanciasBestFit.put( 15,211);
		mInstanciasNombres.put(16,"mscp56.txt"); mInstanciasBestFit.put( 16,213);
		mInstanciasNombres.put(17,"mscp57.txt"); mInstanciasBestFit.put( 17,293);
		mInstanciasNombres.put(18,"mscp58.txt"); mInstanciasBestFit.put( 18,288);
		mInstanciasNombres.put(19,"mscp59.txt"); mInstanciasBestFit.put( 19,279);
		mInstanciasNombres.put(20,"mscp510.txt"); mInstanciasBestFit.put( 20,265);
		mInstanciasNombres.put(21,"mscp61.txt"); mInstanciasBestFit.put( 21,138);
		mInstanciasNombres.put(22,"mscp62.txt"); mInstanciasBestFit.put( 22,146);
		mInstanciasNombres.put(23,"mscp63.txt"); mInstanciasBestFit.put( 23,145);
		mInstanciasNombres.put(24,"mscp64.txt"); mInstanciasBestFit.put( 24,131);
		mInstanciasNombres.put(25,"mscp65.txt"); mInstanciasBestFit.put( 25,161);
		mInstanciasNombres.put(26,"mscpa1.txt"); mInstanciasBestFit.put( 26,253);
		mInstanciasNombres.put(27,"mscpa2.txt"); mInstanciasBestFit.put( 27,252);
		mInstanciasNombres.put(28,"mscpa3.txt"); mInstanciasBestFit.put( 28,232);
		mInstanciasNombres.put(29,"mscpa4.txt"); mInstanciasBestFit.put( 29,234);
		mInstanciasNombres.put(30,"mscpa5.txt"); mInstanciasBestFit.put( 30,236);
		mInstanciasNombres.put(31,"mscpb1.txt"); mInstanciasBestFit.put( 31,69);
		mInstanciasNombres.put(32,"mscpb2.txt"); mInstanciasBestFit.put( 32,76);
		mInstanciasNombres.put(33,"mscpb3.txt"); mInstanciasBestFit.put( 33,80);
		mInstanciasNombres.put(34,"mscpb4.txt"); mInstanciasBestFit.put( 34,79);
		mInstanciasNombres.put(35,"mscpb5.txt"); mInstanciasBestFit.put( 35,72);
		mInstanciasNombres.put(36,"mscpc1.txt"); mInstanciasBestFit.put( 36,227);
		mInstanciasNombres.put(37,"mscpc2.txt"); mInstanciasBestFit.put( 37,219);
		mInstanciasNombres.put(38,"mscpc3.txt"); mInstanciasBestFit.put( 38,243);
		mInstanciasNombres.put(39,"mscpc4.txt"); mInstanciasBestFit.put( 39,219);
		mInstanciasNombres.put(40,"mscpc5.txt"); mInstanciasBestFit.put( 40,215);
		mInstanciasNombres.put(41,"mscpd1.txt"); mInstanciasBestFit.put( 41,60);
		mInstanciasNombres.put(42,"mscpd2.txt"); mInstanciasBestFit.put( 42,66);
		mInstanciasNombres.put(43,"mscpd3.txt"); mInstanciasBestFit.put( 43,72);
		mInstanciasNombres.put(44,"mscpd4.txt"); mInstanciasBestFit.put( 44,62);
		mInstanciasNombres.put(45,"mscpd5.txt"); mInstanciasBestFit.put( 45,61);
		mInstanciasNombres.put(46,"mscpnre1.txt"); mInstanciasBestFit.put( 46,29);
		mInstanciasNombres.put(47,"mscpnre2.txt"); mInstanciasBestFit.put( 47,30);
		mInstanciasNombres.put(48,"mscpnre3.txt"); mInstanciasBestFit.put( 48,27);
		mInstanciasNombres.put(49,"mscpnre4.txt"); mInstanciasBestFit.put( 49,28);
		mInstanciasNombres.put(50,"mscpnre5.txt"); mInstanciasBestFit.put( 50,28);
		mInstanciasNombres.put(51,"mscpnrf1.txt"); mInstanciasBestFit.put( 51,14);
		mInstanciasNombres.put(52,"mscpnrf2.txt"); mInstanciasBestFit.put( 52,15);
		mInstanciasNombres.put(53,"mscpnrf3.txt"); mInstanciasBestFit.put( 53,14);
		mInstanciasNombres.put(54,"mscpnrf4.txt"); mInstanciasBestFit.put( 54,14);
		mInstanciasNombres.put(55,"mscpnrf5.txt"); mInstanciasBestFit.put( 55,13);
		mInstanciasNombres.put(56,"mscpnrg1.txt"); mInstanciasBestFit.put( 56,176);
		mInstanciasNombres.put(57,"mscpnrg2.txt"); mInstanciasBestFit.put( 57,154);
		mInstanciasNombres.put(58,"mscpnrg3.txt"); mInstanciasBestFit.put( 58,166);
		mInstanciasNombres.put(59,"mscpnrg4.txt"); mInstanciasBestFit.put( 59,168);
		mInstanciasNombres.put(60,"mscpnrg5.txt"); mInstanciasBestFit.put( 60,168);
		mInstanciasNombres.put(61,"mscpnrh1.txt"); mInstanciasBestFit.put( 61,63);
		mInstanciasNombres.put(62,"mscpnrh2.txt"); mInstanciasBestFit.put( 62,63);
		mInstanciasNombres.put(63,"mscpnrh3.txt"); mInstanciasBestFit.put( 63,59);
		mInstanciasNombres.put(64,"mscpnrh4.txt"); mInstanciasBestFit.put( 64,58);
		mInstanciasNombres.put(65,"mscpnrh5.txt"); mInstanciasBestFit.put( 65,55);
        
        for (int i=1;i<=cantidadInstancias;i++) {
        	mBestFistInstancias.put(i, mInstanciasBestFit.get(i));
        	mNombresInstancias.put(i,  mInstanciasNombres.get(i));
        }
        	
		return 0;
	}
	
	public static int cargaDatosDeInstancia(String rutaYnombreInstancia) throws FileNotFoundException, IOException
	{
		System.out.print("COMENZANDO A LEER EL ARCHIVO...\n\n");
        String ruta = rutaYnombreInstancia;
        
        String linea = "";
        List<String> elementos = null;
        File archivo = new File(ruta);
        FileReader fr = new FileReader(archivo);
        BufferedReader br = new BufferedReader(fr);
        int numElem = 0, i = 0,  k = 0, auxFichero = 0, flag = 0, aux=0;
//        
//        //LECTURA FICHEROS UNICOST
//        
        try {
	        while (aux == 0) { //leyendo dimensiones de la matriz de restriccion.
	            linea = br.readLine().trim();
	            elementos = Arrays.asList(linea.split(" "));
	            numeroFilas = Integer.parseInt(elementos.get(0));
	            numeroColumnas = Integer.parseInt(elementos.get(1));
	            costos = new int[numeroColumnas];
	            System.out.print("Archivo: "+ruta+"\nFilas: "+numeroFilas+"\nColumnas:"+numeroColumnas+"\n\n");
	            
	            while (numElem != 1) { //llenando el vector de costos asociados a cada columna/dimensión/variable.
	                linea = br.readLine().trim();
	                elementos = Arrays.asList(linea.split(" "));
	                numElem = elementos.size();
	                for (int j = i; j < costos.length && k != elementos.size() && numElem != 1; j++) {
	                    costos[j] = Integer.parseInt(elementos.get(k));
	                    k++;
	                }
	                if (numElem == 1) {
	                    flag = Integer.parseInt(elementos.get(0));
	                }
	                k = 0;
	                i += elementos.size();
	                
	            }
	            System.out.print("costos cargados OK\n");
	            k = 0;
	            linea = br.readLine().trim();
	            elementos = Arrays.asList(linea.split(" "));
	            restricciones = new int[numeroFilas][numeroColumnas];
	            System.out.print("inicio carga Restricciones...\n elementos a cargar : "+elementos+"\n");
	            System.out.print("flag: "+flag+"\nauxFichero: "+auxFichero+"\n");
	            System.out.print("flag: "+elementos.size()+"\n");
	            
	            for (i = 0; i < numeroFilas; i++) { // llenando matriz de restricciones
	                while (flag != auxFichero) {
	                    auxFichero = auxFichero + elementos.size();
	                    
	                    while (k < elementos.size()) {
	                        restricciones[i][Integer.parseInt(elementos.get(k)) - 1] = 1;
	                        k++;
	                        
	                    }
	                    k = 0;
	                    if ((linea = br.readLine()) != null) {
	                        elementos = Arrays.asList(linea.trim().split(" "));
	                    }
//	                    System.out.print(" "+flag+"!="+auxFichero+"?\n");
	                    return 0;
	                }
	                System.out.print("Fila: " +i +" cargada OK\n");
		            
	                auxFichero = 0;
	                flag = Integer.parseInt(elementos.get(0));
	                if ((linea = br.readLine()) != null) {
	                    elementos = Arrays.asList(linea.trim().split(" "));
	                }
	                for (int j = 0; j < numeroColumnas; j++) {
	                    if (restricciones[i][j] != 1) {
	                        restricciones[i][j] = 0;
	                    }
	                }
	
	            }
	            aux = 1;
	        }
	        System.out.println("Archivo cargado correctamente");
	        
            //CS.generarExcel(numerofilas,numerocolumnas,numeroIteraciones,fitness[posicionmejor],fitness[posicionPeor],fBinarizacion,id,archivo.getName().replace(".txt", ""),repActual,tiempoInicio,mejorIteracion);
        } catch (Exception e) {
            e.printStackTrace();
        }
		return 0;
	}
	
	
    public static void LeeArchivoInstancia(String rutaYnombreInstancia) {
    	fs = true;
        ss = true;

        rs = 0;
        rc = 0;
        cc = 0;
        cr = 0;
        BufferedReader br = null;
        String line;

        try {
            br = new BufferedReader(new FileReader(rutaYnombreInstancia));
            while ((line = br.readLine()) != null) {
                ProcesarLinea(line);
            }
        } catch (IOException ex) {
            logger.log(Level.SEVERE, null, ex);
        } finally {
            try {
                if (br != null) {
                    br.close();
                }
            } catch (IOException ex) {
                logger.log(Level.SEVERE, null, ex);
            }
        }
    }
    
	public static void ProcesarLinea(String line) {
	        String[] values = line.trim().split(" ");

	        if (fs) {
	            numeroFilas = Integer.parseInt(values[0]);
	            numeroColumnas = Integer.parseInt(values[1]);
	            restricciones = new int[numeroFilas][numeroColumnas];
	            costos = new int[numeroColumnas];
	            fs = false;
	        } else {
	            if (ss) {
	                for (int i = 0; i < values.length; i++) {
	                    costos[cc++] = Integer.parseInt(values[i]);
	                }
	                ss = cc < numeroColumnas;
	            } else {
	                if (rc == 0) {
	                    rc = Integer.parseInt(values[0]);
	                } else {
	                    for (int i = 0; i < values.length; i++) {
	                        restricciones[rs][Integer.parseInt(values[i]) - 1] = 1;
	                        cr++;
	                    }
	                    if (rc <= cr) {
	                        rs++;
	                        rc = 0;
	                        cr = 0;
	                    }
	                }
	            }
	        }
	    }

	public static int cargaTiposDeBinarizaciones (int cantidadBinarizaciones)
	{
		
		Map<Integer, String> mBinarizaciones = new HashMap<Integer, String>(); //lista de columnas restricciones, con su respectivo índice
		mBinarizaciones.put(1, "sshape1");
		mBinarizaciones.put(2, "sshape2");
		mBinarizaciones.put(3, "sshape3");
		mBinarizaciones.put(4, "sshape4");
		mBinarizaciones.put(5, "vshape1");
		mBinarizaciones.put(6, "vshape2");
		mBinarizaciones.put(7, "vshape3");
		mBinarizaciones.put(8, "vshape4");
		mBinarizaciones.put(9, "vshape5");
		mBinarizaciones.put(10, "basic");
		mBinarizaciones.put(11, "standard");
		mBinarizaciones.put(12, "complement");
		mBinarizaciones.put(13, "staticProbability");
		mBinarizaciones.put(14, "elitist");

		for (int i = 1; i<=cantidadBinarizaciones; i++) {
			mTiposDeBinarizacion.put(i,  mBinarizaciones.get(i));
		}
		return 0;
	}
	
	private void generarExcel(int numerofilas, int numerocolumnas, int numeroIteraciones, float mejorSolucion, float peorSolucion, String fBinarizacion, long id, String nombreArchivo, int repActual, long tiempoInicio, int mejorIteracion) throws IOException {
        String rutaArchivo = System.getProperty("user.home") + "/DESKTOP/experimentos/oct2014/" + nombreArchivo + ".xls";
        File archivoXLS = new File(rutaArchivo);
        Sheet hoja = null;
        FileOutputStream archivo = null;
        if (!archivoXLS.exists()) {
            archivo = new FileOutputStream(archivoXLS);
            archivoXLS.createNewFile();
            Workbook libro = new HSSFWorkbook();
            hoja = libro.createSheet("Mi hoja de trabajo 1");
            Row fila = hoja.createRow(0);
            Cell celda1 = fila.createCell(0);
            Cell celda2 = fila.createCell(1);
            Cell celda3 = fila.createCell(2);
            Cell celda4 = fila.createCell(3);
            Cell celda5 = fila.createCell(4);
            Cell celda6 = fila.createCell(5);
            Cell celda7 = fila.createCell(6);
            Cell celda8 = fila.createCell(7);
            Cell celda9 = fila.createCell(8);
            Cell celda10 = fila.createCell(9);
            Cell celda11 = fila.createCell(10);
            Cell celda12 = fila.createCell(11);
            Cell celda13 = fila.createCell(12);
            Cell celda14 = fila.createCell(13);
            Cell celda15 = fila.createCell(14);
            celda1.setCellValue(nombreArchivo.replace(".txt", "").toUpperCase());
            celda2.setCellValue("Nº FILAS");
            celda3.setCellValue("Nº COLUMNAS");
            celda4.setCellValue("Nº ITERACIONES");
            celda5.setCellValue("Nº NIDOS");
            celda6.setCellValue("P(A)");
            celda7.setCellValue("F. DE BINARIZACION");
            celda8.setCellValue("OPTIMO GLOBAL");
            celda9.setCellValue("MEJOR SOLUCION");
            celda10.setCellValue("PEOR SOLUCION");
            celda11.setCellValue("TIEMPO");
            celda12.setCellValue("ID EXPERIMENTO");
            celda13.setCellValue("REPETICION");
            celda14.setCellValue("GRAFICA");
            celda15.setCellValue("MEJOR ITERACION");
            libro.write(archivo);
            archivo.close();
        }
        FileInputStream input = new FileInputStream(archivoXLS);
        Workbook libro = new HSSFWorkbook(input);
        /*CreationHelper createHelper = libro.getCreationHelper();
        Hyperlink link = createHelper.createHyperlink(Hyperlink.LINK_FILE);*/
        archivo = new FileOutputStream(archivoXLS);
        hoja = libro.getSheetAt(0);
        int a = hoja.getLastRowNum();
        Row fila = hoja.createRow(a + 1);
        Cell celda1 = fila.createCell(0);
        Cell celda2 = fila.createCell(1);
        Cell celda3 = fila.createCell(2);
        Cell celda4 = fila.createCell(3);
        Cell celda5 = fila.createCell(4);
        Cell celda6 = fila.createCell(5);
        Cell celda7 = fila.createCell(6);
        Cell celda8 = fila.createCell(7);
        Cell celda9 = fila.createCell(8);
        Cell celda10 = fila.createCell(9);
        Cell celda11 = fila.createCell(10);
        Cell celda12 = fila.createCell(11);
        Cell celda13 = fila.createCell(12);
        Cell celda14 = fila.createCell(13);
        Cell celda15 = fila.createCell(14);
        celda1.setCellValue(nombreArchivo);
        celda2.setCellValue(numerofilas);
        celda3.setCellValue(numerocolumnas);
        celda4.setCellValue(numeroIteraciones);
        celda5.setCellValue(this.cantNidos);
        celda6.setCellValue(this.probDescub);
        celda7.setCellValue(fBinarizacion);
        celda8.setCellValue("");
        celda9.setCellValue(mejorSolucion);
        celda10.setCellValue(peorSolucion);
        celda11.setCellValue(System.currentTimeMillis() - tiempoInicio);
        celda12.setCellValue(String.valueOf(id));
        celda13.setCellValue(repActual);
        celda14.setCellValue("VER GRAFICO");
        celda15.setCellValue(mejorIteracion);
        //link.setAddress(System.getProperty("user.home")+"/DESKTOP/experimentos/images/"+id+".jpg");
        //celda14.setHyperlink((org.apache.poi.ss.usermodel.Hyperlink)link);
        libro.write(archivo);
        archivo.close();
    }

    private static String Write(int b, Object o) {
        String line = "";
        for (int i = 0; i < b - String.valueOf(o).length(); i++) {
            line += " ";
        }
        return (line + o + " |");
    }
	
	private static void Save(int ejecucion, String fileName,int cantNidos, CuckooSearch cs_scp, int knowFitInstancia, String nombreInstancia) {
//		|Nº EJECUCION | NIDOS | BINARIZACION  |ITERACIONES|  SEMILLA     | MEJOR FITNESS |    FITNESS FOUND| TIME |\n");
        BufferedWriter bufferedWriter = null;
        File file;
        String line = "|";

        try {
            file = new File(fileName);
            boolean exists = file.exists();

            if (!exists) {
                (new File(file.getParent())).mkdirs();
            }

            bufferedWriter = new BufferedWriter(new FileWriter(file, true));

            try (PrintWriter pw = new PrintWriter(bufferedWriter)) {
                if (!exists) {
                    line += Write(2, "#") + 
                    		Write(5, "Nest") + 
                    		Write(13, "Binarizacion") + 
                    		Write(6, "%Desc") + 
                    		Write(5, "#Iter") + 
                    		Write(13, "semilla") + 
                    		Write(8, "BestFit");
                    
                    line += Write(8, "GotFit") + 
                    		Write(11, "instancia") + 
                    		Write(5, "time");
                    pw.println(line);
                    line = "";
                    for (int i = 0; i < 97; i++) {
                        line += "-";
                    }
                    pw.println(line);
                    line = "|";
                }

                line += Write(2, ejecucion) + 
                		Write(5, cantNidos) + 
                		Write(13, cs_scp.getTipoBinarizacion()) + 
                		Write(6, cs_scp.getProbDescubrimiento()) + 
                		Write(5, cs_scp.getNumIteraciones()) + 
                		Write(13, cs_scp.getSemilla()) + 
                		Write(8, knowFitInstancia) +
                		Write(8, cs_scp.getBestFit());
                line += Write(11, nombreInstancia) +  
                		Write(5, (String.format("%.2g%n", (cs_scp.getTiempoTermino()-cs_scp.getTiempoInicioEjecucion()) / (1000f))).trim());
                pw.println(line);
            }
        } catch (IOException ex) {
            logger.log(Level.SEVERE, null, ex);
        } finally {
            try {
                if (bufferedWriter != null) {
                    bufferedWriter.close();
                }
            } catch (IOException ex) {
                logger.log(Level.SEVERE, null, ex);
            }
        }
    }
	
	public static void main(String[] args) throws FileNotFoundException, IOException 
	 {
		 int cantNidos = 25;
		 float probDescub = (float)0.25;
		 int numeroIteraciones = 2500; 
//		 int cantInstancias = 65, cantTiposBinarizaciones = 14;
		 int cantInstancias = 65, cantTiposBinarizaciones = 1;
		 
//		 String binarizacion = "standard";
		 String nombreArchivoSalida = "resources/input/";
		 try {
			 cargaInstancias(cantInstancias);
	
			 cargaTiposDeBinarizaciones(cantTiposBinarizaciones);
	
			 Scanner in = new Scanner(System.in);
			 System.out.println("\nIngresa la Discretizacion a utilizar: ");
			 String tipoDiscretizacion = in.nextLine();
			 
			 System.out.println("\nIngresa la Binarizacion a utilizar: ");
			 String tipoBinarizacion = in.nextLine();
			 
			 System.out.println("Procesando instancias con la siguiente config.\n Discretizacion: "+tipoDiscretizacion+" \n binarizacion: "+tipoBinarizacion+"\n");
				 
	
			 CuckooSearch CS_SCP1 = new CuckooSearch(cantNidos, 
	        												probDescub,  
	        												numeroIteraciones,
	        												mNombresInstancias,
	        												mBestFistInstancias,
	        												tipoDiscretizacion,
	        												tipoBinarizacion,
	        												costos,
	        												restricciones,
	        												numeroFilas,
	        												numeroColumnas);
			 
	
			  CS_SCP1.start();
		 }catch (Exception e) {
			 e.printStackTrace();
		 }
		 
    }

}
